
Có nhiều đối tượng mà chúng ta chỉ cần một thể hiện như là: nhóm luồng, bộ nhớ đệm, hộp thoại, đối tượng xử lý tùy chọn, cài đặt và đăng nhập (loging), đối tượng được sử dụng để ghi nhật ký và đối tượng hoạt động như trình điều khiển thiết bị cho các thiết bị như máy in và card đồ họa.\\

Trên thực tế, đối với nhiều loại đối tượng này, nếu chúng ta khởi tạo nhiều đối tượng, chúng ta sẽ gặp phải tất cả các loại vấn đề như hành vi chương trình không chính xác, sử dụng quá mức tài nguyên hoặc kết quả không nhất quán. Để xử lý vấn đề này, Singleton Pattern ra đời với quy ước đảm bảo một và chỉ một đối tượng được khởi tạo cho một lớp nhất định.

% Section 1: Định nghĩa ....-------------
\section{Định nghĩa và mục đích sử dụng}

{\centering 
{\large
“Singleton is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this instance”}\par}

Singleton là \textbf{creational design pattern} cho phép bạn đảm bảo rằng một lớp chỉ có một thể hiện \textbf{(instance}) duy nhất. Do thể hiện này có tiềm năng sử dụng trong suốt chương trình, nên Singleto Pattern cũng cung cấp một điểm truy cập toàn cục đến nó.

- Mục đích sử dụng:
\begin{itemize}
\item Đảm bảo rằng 1 class chỉ có 1 instance duy nhất và class này luôn sẵn sàng để sử dụng ở bất kỳ thời điểm hoặc vị trí nào trong phần mềm ứng dụng của chúng ta.
\item Việc quản lý việc truy cập tốt hơn vì chỉ có một thể hiện duy nhất.
\item Có thể quản lý số lượng thể hiện của một lớp trong giới hạn chỉ định.
\end{itemize}
% end section 1 .....----------------

% Section 2: Mô hình .....------------------
\section{Mô hình cấu trúc}

\begin{figure}[h]
\centerline{\includegraphics[scale=0.75]{Picture/SingletonPattern/SingletonPattern_mohinh.png}}
\caption{Mô hình cấu trúc của Singleton Pattern}
\end{figure} 

Lớp Singleton khai báo với private constructor để hạn chế việc class được truy cập từ bên ngoài, biến tĩnh uniqueInstance để chứa thể hiện của nó và phương thức public static getInstance trả về cùng instance được khởi tạo ở trên:  

\begin{itemize}
\item Nếu uinqueInstance có giá trị null thì phương thức sẽ khởi tạo Singleton thông qua phương thức khởi tạo riêng của nó và gán nó cho uniqueInstance
\item Nếu uniqueInstance có giá trị khác null nghĩa là nó đã được khởi tạo trước đó. Lúc này phương thức chỉ cần trả lại giá trị uniqueInstance.
\item Phương thức getInstance() là tĩnh, có nghĩa là nó là class method, vì vậy bạn có thể truy cập phương thức này một cách thuận tiện từ bất kỳ đâu trong mã của mình bằng cách sử dụng Singleton.getInstance(). Điều đó cũng dễ dàng như việc truy cập một biến toàn cục. 
\end{itemize}
% end Section 2: .....--------------------

% Section 3: ............------------------
\section{Các cách triển khai Singleton Pattern}

\subsection{Lazy Initialization}
\noindent
- Khi nào cần thì mới khởi tạo.\\
- Việc triển khai ở trên hoạt động tốt trong trường hợp môi trường đơn luồng nhưng khi nói đến hệ thống đa luồng, nó có thể gây ra sự cố nếu nhiều luồng bên trong điều kiện if cùng một lúc. Nó sẽ phá hủy mẫu singleton và cả hai luồng sẽ nhận được các thể hiện khác nhau của lớp singleton.

\subsection{Eager initialization}
\noindent
- Lớp luôn luôn tồn tại 1 instance đã được khởi tạo sẵn, kể cả khi ta chưa sử dụng đến nó.\\
- Nếu lớp singleton của bạn không sử dụng nhiều tài nguyên, thì đây là cách tiếp cận để sử dụng. Nhưng trong hầu hết các trường hợp, các lớp Singleton được tạo cho các tài nguyên như Hệ thống tệp, kết nối cơ sở dữ liệu, v.v. Chúng ta nên tránh việc khởi tạo cho đến khi máy khách gọi phương thức getInstance. Ngoài ra, phương pháp này không cung cấp bất kỳ tùy chọn nào để xử lý ngoại lệ.\\
- Để có thể xử lý ngoại lệ ta có thể dùng đến static block.

\subsection{Thread Safe Singleton}
\noindent
- Về phía nhiều luồng cách khởi tạo này là an toàn.\\
- Cách dễ dàng hơn để tạo một lớp singleton an toàn cho luồng là làm cho phương thức truy cập toàn cục được đồng bộ hóa, để chỉ một luồng có thể thực thi phương thức này tại một thời điểm.

\subsection{Double Check Locking Singleton}
\noindent
- Việc triển khai Thread Safe Singleton hoạt động tốt và cung cấp sự an toàn cho luồng nhưng nó làm giảm hiệu suất do chi phí liên quan đến phương pháp được đồng bộ hóa, mặc dù chúng tôi chỉ cần nó cho một vài luồng đầu tiên có thể tạo các phiên bản riêng biệt. Để tránh chi phí tăng thêm này mỗi lần, nguyên tắc khóa được kiểm tra hai lần được sử dụng. Trong cách tiếp cận này, khối được đồng bộ hóa được sử dụng bên trong điều kiện if với một kiểm tra bổ sung để đảm bảo rằng chỉ một thể hiện của một lớp singleton được tạo.
% end Section 3: .....--------------------

% Section 4: ............------------------
\section{Code minh họa}
\subsection{Database conection}
Điều gì đang thực sự xảy ra ở đây? Chúng ta đang tham gia một lớp DataBase và để nó quản lý một phiên bản duy nhất của chính nó. Chúng ta cũng đang ngăn không cho bất kỳ lớp nào khác tự tạo một phiên bản mới hay nói theo cơ sở dữ liệu là chúng ta không tạo thêm kết nối đến cơ sở dữ liệu đó. Để có được một phiên bản, bạn phải đi qua chính lớp DataBase đó nếu đã tồn tại kết nối thì nó sẽ đưa nó cho bạn nếu không thì nó sẽ tạo kết nối mới. \\

Lớp DataBase định nghĩa phương thức `getInstance` cho phép client truy cập vào cùng một phiên bản kết nối đến DataBase trong suốt chương trình. \\

Ở trường hợp này chúng ta cũng đang cung cấp một điểm truy cập toàn cầu cho phiên bản: bất cứ khi nào bạn cần một phiên bản, chỉ cần truy vấn lớp và nó sẽ trả lại cho bạn phiên bản duy nhất. Như bạn đã thấy, chúng tôi có thể triển khai điều này để Singleton được tạo theo cách lười biếng(\textbf{Lazy Initialization}), điều này đặc biệt quan trọng đối với các đối tượng sử dụng nhiều tài nguyên. \\

\subsection{More Database conection}
Giả sử nếu bạn đang mở 1 chương trình hai lần để kết nối đến DataBase hay nói cách khác bạn sẽ tạo được 2 kết nối khác nhau đến cùng DataBase trên cùng một máy. Đó là vấn đề ở đây. Khi ở các luồng khác nhau hay bộ nhớ mà mỗi chương trình được cấp tách biệt nhau thì làm sao nó có thể biết có một chương trình giống nó mà đã kết nối tới DataBase rồi.\\

Trong code, ta thực tế hóa điều đó như thế nào: điều đó thật đơn giản nó là đa luồng (multithreading) khi ta tạo hai luồng song song và cùng tạo kết nối đến DataBase thì sẽ như thế nào ?. \\
% end Section 4: .....--------------------

\section{Nhược điểm và ưu điểm}

bla bla bla..

\section{Ứng dụng Singleton Pattern trong thực tế}
bla bla bla..

% \begin{enumerate}
% %\item Chapter \ref{CH1} introduces bla bla
% % \item Chapter \ref{CH2} shows bla bla
% % \item Chapter \ref{CH3} shows bla bla
% % \item Chapter \ref{CH4} demonstrates bla bla
% % \item Chapter \ref{CH5} draws a conclusion for the report and introduces ideas for future work.
% \end{enumerate}